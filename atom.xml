<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Syou</title>
  
  <subtitle>乌鸦为什么像写字台</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://twentyshaw.github.io/"/>
  <updated>2019-11-17T09:42:32.800Z</updated>
  <id>https://twentyshaw.github.io/</id>
  
  <author>
    <name>Syou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS代码题4</title>
    <link href="https://twentyshaw.github.io/2019/11/17/JS%E4%BB%A3%E7%A0%81%E9%A2%984/"/>
    <id>https://twentyshaw.github.io/2019/11/17/JS代码题4/</id>
    <published>2019-11-17T09:30:36.000Z</published>
    <updated>2019-11-17T09:42:32.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现一个简单的模板引擎"><a href="#实现一个简单的模板引擎" class="headerlink" title="实现一个简单的模板引擎"></a>实现一个简单的模板引擎</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let template = &apos;&#123;&#123;name&#125;&#125;是&#123;&#123;color&#125;&#125;的&#123;&#123;stuff&#125;&#125;&apos;;</span><br><span class="line">let data = &#123;</span><br><span class="line">  name: &apos;香蕉&apos;,</span><br><span class="line">  color: &apos;黄色&apos;,</span><br><span class="line">  stuff: &apos;水果&apos;</span><br><span class="line">&#125;</span><br><span class="line">render(template, data); // 香蕉是黄色的水果</span><br></pre></td></tr></table></figure><p>实现render函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function render(template,data)&#123;</span><br><span class="line">var reg = /\&#123;\&#123;(\w+)\&#125;\&#125;/</span><br><span class="line">var item</span><br><span class="line">if (reg.test(template)) &#123;</span><br><span class="line">while(reg.exec(template) !== null)&#123;</span><br><span class="line">item = reg.exec(template)[1]</span><br><span class="line">template = template.replace(reg,data[item]) </span><br><span class="line">&#125;</span><br><span class="line">return template</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return &quot;没有可替换项目&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的主要考察正则的有关知识：</p><ul><li>圆括号</li><li>test()方法</li><li>exec()方法</li><li>replace()方法</li></ul><p>简单学习一下：</p><h4 id="1-正则表达式中的圆括号-→-（）"><a href="#1-正则表达式中的圆括号-→-（）" class="headerlink" title="1. 正则表达式中的圆括号 → （）"></a>1. 正则表达式中的圆括号 → （）</h4><p>看看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-capturing-parentheses" target="_blank" rel="noopener">MDN</a>的解释</p><blockquote><p>(x) : 它会匹配 ‘x’ 并且记住匹配项。其中括号被称为<strong>捕获括号</strong>。<br>模式 <code>/(foo) (bar) \1 \2/</code> 中的 ‘<code>(foo)</code>‘ 和 ‘<code>(bar)</code>‘ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 <code>\1</code> 和 <code>\2</code> 表示第一个和第二个被捕获括号匹配的子字符串，即 <code>foo</code> 和 <code>bar</code>，匹配了原字符串中的后两个单词。注意 <code>\1</code>、<code>\2</code>、…、<code>\n</code> 是用在正则表达式的匹配环节。而在正则表达式的替换环节，则要使用像 <code>$1</code>、<code>$2</code>、…、<code>$n</code> 这样的语法，例如，<code>&#39;bar foo&#39;.replace(/(...) (...)/, &#39;$2 $1&#39;)</code>。<code>$&amp;</code> 表示整个用于匹配的原字符串。</p></blockquote><ul><li>它会<strong>记住</strong>被匹配到的项目</li><li>可以在replace()方法中用<code>$n</code>调取第n个括号匹配到的内容</li></ul><h4 id="2-test-方法"><a href="#2-test-方法" class="headerlink" title="2. test()方法"></a>2. test()方法</h4><p>用法：<code>regexObj.test(str)</code>，返回一个true(存在匹配项目)或者false(不存在匹配项目)<br>如果正则表达式被设定为全局匹配，如：<code>/\{\{(\w+)\}\}/g</code>，那么它会查找整个表达式。虽然是否为全局匹配并不影响返回的结果，但是全局匹配的正则对象的test()方法每调用一次，它的lastIndex就会移动到被查找到的内容跟的最后一个字符的位置。<br>比如在本题中，如果在判断的时候调用了 <code>reg.test(template)</code>，那它后面的语句：<code>reg.exec(template)</code>的匹配的起始位置就不是从0位开始，而是从lastIndex=8的位置开始了。</p><h4 id="3-exec-方法"><a href="#3-exec-方法" class="headerlink" title="3. exec()方法"></a>3. exec()方法</h4><p>用法：<code>regexObj.exec(str)</code>，如果匹配失败会返回null。但如果匹配成功，会返回一个数组：</p><ul><li>数组第一项（arr[0]）：匹配到的内容</li><li>arr[1]~arr[n]：如果正则表达式中有圆括号的话，arr[n]为第n个圆括号中的内容。如果表达式中没有圆括号，那么这些项将不存在。</li><li>index属性：匹配到的字符位于原始字符串的基于0的索引值</li><li>input属性：原始字符串</li><li>等等</li></ul><p>如果正则表达式是全局匹配，那么和test()方法相同，每调用一次，正则对象的lastIndex都会改变，从而exec()会依次返回所有匹配的项目。但如果不是全局匹配，那无论调用几次exec()，都会返回第一次匹配到的内容。</p><h4 id="4-replace-方法"><a href="#4-replace-方法" class="headerlink" title="4. replace()方法"></a>4. replace()方法</h4><p>用法：<code>str.replace(regexp|substr, newSubStr|function)</code>，它会返回更新后的字符串</p><ul><li>regexp：正则对象/正则表达式。该正则所匹配的内容会被第二个参数的返回值替换掉。</li><li>substr：直接给出一个字符串来匹配</li><li>newSubStr：希望取代匹配到的内容的新的字符串</li><li>function：一个函数。该函数return的内容将取代匹配到的字符串。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实现一个简单的模板引擎&quot;&gt;&lt;a href=&quot;#实现一个简单的模板引擎&quot; class=&quot;headerlink&quot; title=&quot;实现一个简单的模板引擎&quot;&gt;&lt;/a&gt;实现一个简单的模板引擎&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="正则" scheme="https://twentyshaw.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议学习笔记（3）</title>
    <link href="https://twentyshaw.github.io/2019/11/17/HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    <id>https://twentyshaw.github.io/2019/11/17/HTTP协议学习笔记（3）/</id>
    <published>2019-11-17T02:07:04.000Z</published>
    <updated>2019-11-17T02:12:31.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><h4 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1. 三次握手"></a>1. 三次握手</h4><p>还是要祭出那张熟悉的图</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/5426662-d94f3226a689847c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自互联网"></p><ul><li><strong>第一次握手</strong>：首先由客户端主机主动发起建立连接的请求<br>该请求为一个TCP报文。该报文段首部中的SYN=1，ACK=0。由于SYN=1的报文段不能携带数据但会消耗一个序列号（由自身主机随机生成），所以假设它产生了一个值为x的序列号→seq=x。并且，ACK=0的报文段没有确认号（ack）。所以第一次握手的TCP报文首部为图示的：<br>SYN=1，seq=x</li><li><strong>第二次握手</strong>：服务端主机同意建立连接<br>服务端会响应一个TCP报文。该报文段首部SYN=1，ACK=1。<strong>发起连接和同意建立连接的SYN都为1。</strong>因为SYN=1，所以该报文段也会带上一个序列号，这个序列号也是由服务端自己随机生成的一个值。如图，假设它为y→seq=y。但是，由于本次报文中ACK=1，所以他有一个确认号ack，为服务端从对方主机（客户端）接收到的数据序列号（第一次握手发过来的seq=x）加上1，所以他的确认号为：<strong>ack=x+1</strong>。综上，第二次握手TCP报文首部为：<br>SYN=1，ACK=1，seq=y，ack=x+1</li><li><strong>第三次握手</strong>：客户端主机表示收到了服务端同意的消息<br>客户端收到服务端响应的消息后，它会再发一个TCP报文，来告诉服务端自己知道了。这个报文首部SYN=0，ACK=1。<strong>由于本次握手发送的报文SYN=0，所以报文段已经可以携带数据了</strong>。它的seq为自己在第一次握手随机创建的序列号（x）加1→seq=x+1。表示自己这次发送的TCP报文中的数据是接着上一次给对方发的数据包的（虽然上一次没有数据包）。然后，它的ack为服务端响应的seq的值加1→ack=y+1。表示你上次发的y我已经收到了，你可以给我发后面的数据（y+1）了。所以，本次握手的TCP报文为：<br>ACK=1，seq=x+1，ack=y+1</li></ul><p><strong>至此，完成了建立TCP连接的三次握手。从上面的过程中，我得出一个结论：序列号（seq）是用来标识自己本次发送的数据，确认号（ack）是用来提醒对方自己要接受的数据</strong></p><hr><h4 id="2-TCP连接的释放——四次挥手"><a href="#2-TCP连接的释放——四次挥手" class="headerlink" title="2. TCP连接的释放——四次挥手"></a>2. TCP连接的释放——四次挥手</h4><p>看看过程：<br><img src="https://upload-images.jianshu.io/upload_images/5426662-26b986db7a0be705.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自互联网"></p><p>数据传输结束后，通信双方可以关闭连接，并且停止发送数据。</p><ul><li><strong>第一次挥手</strong>：客户端主机主动请求关闭连接。<br>它会发送一个释放连接的报文段并且不携带任何数据。该报文段的FIN=1，seq为前面传输的数据序列号加1，假设他为u→seq=u。<strong>TCP规定，在FIN=1的报文段，即使没有携带数据也要消耗一个序列号。</strong>客户端发出这个报文以后，就进入终止等待1（FIN-WAIT-1）的阶段，等待服务端的响应。</li><li><strong>第二次挥手</strong>：服务端向客户端确认：我要开始释放连接了哦<br>服务端收到客户端传来的释放连接的报文段以后，会先返回一个确认的报文段。该报文段ACK=1，确认号为客户端传来的报文段的序列号加1→ack=u+1。他的序列号为自己前面发送的最后的数据的序列号加1 ，假设它为v→seq=v。<br>这时客户端收到这个确认报文以后会进入终止等待2（FIN-WAIT-2）的阶段，该阶段客户端已经不能再向服务端发送数据了，但是它还可以接收服务端发送过来的数据。</li><li><strong>第三次挥手</strong>：如果服务端已经没有要发给客户端的数据了，他会通知应用进程释放连接。<br>服务端发送一个报文段，FIN=1，ACK=1，确认号仍然是第二次挥手报文段中的确认号ack=u+1。序列号为第二次挥手时，最后传给客户端的数据的序列号加1，假设它为w→seq=w。</li><li><strong>第四次挥手</strong>：客户端收到服务端的确认报文以后，再次与服务端确认，告诉他自己会关闭连接。<br>客户端发送一个确认报文段，ACK=1，确认号为第三次握手中服务端传过来的序列号加1→ack=w+1。它的序列号为自己前一次（第一次握手时）发送的报文序列号加1→seq=u+1。<br>发出该报文后，客户端并不会马上关闭连接，它会进入TIME-WAIT状态。这是一个等待时间，可以自己设定。然而服务端收到报文以后会先马上进入CLOSED状态。客户端只有过了等待时间以后才进入CLOSED状态。二者都进入CLOSED状态后，连接就完全释放了</li></ul><p>至此，四次挥手完成，连接释放。<br>可以看到FIN=1这个字段，只会出现在客户端或服务端提醒对方要关闭连接的时候（第一次握手和第三次握手）。客户端或服务端在收到对方的关闭连接的报文后，都会与对方再次确认。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;三次握手与四次挥手&quot;&gt;&lt;a href=&quot;#三次握手与四次挥手&quot; class=&quot;headerlink&quot; title=&quot;三次握手与四次挥手&quot;&gt;&lt;/a&gt;三次握手与四次挥手&lt;/h3&gt;&lt;h4 id=&quot;1-三次握手&quot;&gt;&lt;a href=&quot;#1-三次握手&quot; class=&quot;headerlink&quot; title=&quot;1. 三次握手&quot;&gt;&lt;/a&gt;1. 三次握手&lt;/h4&gt;&lt;p&gt;还是要祭出那张熟悉的图&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="计算机基础" scheme="https://twentyshaw.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="HTTP" scheme="https://twentyshaw.github.io/tags/HTTP/"/>
    
      <category term="计算机基础" scheme="https://twentyshaw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议学习笔记（2）</title>
    <link href="https://twentyshaw.github.io/2019/11/14/HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <id>https://twentyshaw.github.io/2019/11/14/HTTP协议学习笔记（2）/</id>
    <published>2019-11-14T06:33:43.000Z</published>
    <updated>2019-11-14T06:34:58.940Z</updated>
    
    <content type="html"><![CDATA[<h3 id="客户端与服务端的通信与TCP连接"><a href="#客户端与服务端的通信与TCP连接" class="headerlink" title="客户端与服务端的通信与TCP连接"></a>客户端与服务端的通信与TCP连接</h3><h4 id="1-客户端与服务端的通信过程"><a href="#1-客户端与服务端的通信过程" class="headerlink" title="1. 客户端与服务端的通信过程"></a>1. 客户端与服务端的通信过程</h4><p>当客户端想要跟服务端进行信息交互时，过程如下：</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/5426662-30cb7d90d36b6a57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h4 id="2-TCP连接"><a href="#2-TCP连接" class="headerlink" title="2. TCP连接"></a>2. TCP连接</h4><p>准备面试的时候背过好多次下面这个图，描述了TCP连接建立三次握手的过程：<br><img src="https://upload-images.jianshu.io/upload_images/5426662-d94f3226a689847c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自互联网"></p><p>当时只知道大致就是：</p><blockquote><p>客户端发送一个同步报文请求建立连接，服务端响应一个同步-应答报文表示可以建立连接，然后客户端再发送一个应答报文表示了解了。至此三次握手完成，TCP连接建立，客户端开始发送数据。</p></blockquote><p>上面的回答没有错，但感觉很粗略，现在通过分解知识点的方法来详细学习一下这个过程。</p><h5 id="2-1-首先来看一下TCP报文中包含哪些东西："><a href="#2-1-首先来看一下TCP报文中包含哪些东西：" class="headerlink" title="2.1 首先来看一下TCP报文中包含哪些东西："></a>2.1 首先来看一下TCP报文中包含哪些东西：</h5><p><img src="https://upload-images.jianshu.io/upload_images/5426662-7d857ea15f269183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自互联网"><br>结合三次握手那张图来看我认为自己目前需要了解的是：</p><ul><li><strong>序列号 **：就是握手过程中的那个</strong>seq**。<br>我们知到TCP之所以是可靠的因为他保证了传送数据包的顺序。这个顺序就是通过序列号来实现的。直接看一看定义：<blockquote><p>序列号占4个字节，序号的范围为[0,4284967296]。由于TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号。另外，序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了0。</p></blockquote></li></ul><p>看这段定义时我有点疑惑，他说<strong>“首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号”</strong>，但是在三次握手建立连接的过程中，TCP报文中应该没有带着数据的，那为什么还会有序列号呢？<br>学习的时候看到了一个解释：</p><blockquote><p>TCP规定，SYN=1的报文段不能携带数据（也就是说三次握手的前两次是不可以携带数据的），但要消耗掉一个序号。</p></blockquote><p>该序列号为<strong>初始序列号</strong>，由发起会话的主机随机产生，可能是0和4,294,967,295之间的任意值。<br>当服务端主机接收到请求时，会响应一个TCP报文，该报文中的序列号则是由服务端随机产生，不过该报文中会包含一个<strong>确认号（ack）</strong>，值为客户端的初始序列号+1。关于确认号在下面介绍。</p><hr><ul><li><strong>确认号：ack, 注意是小写啊</strong><blockquote><p>当ACK标志位为1时有效，表示期望收到的下一个报文段的第一个数据字节的序号。确认号为N，则表明到序列号N-1为止的所有数据字节都已经被正确地接收到了。</p></blockquote></li></ul><p>我自己的理解是，带有“ACK=1”字段的报文是主机表示了解，也就是跟对方确认自己收到了信息的意思。所以确认号就是用来表示：<br><strong>“你前一次传过来的数据（n）我都收到了，可以发后面的数据（n+1）了”</strong><br>所以用对方（前一次）的序列号＋1来表示我准备好接收后面的数据了。</p><hr><ul><li><strong>SYN：同步序号</strong><blockquote><p>用来发起一个连接。当SYN=1而ACK=0时，表明这是一个连接请求报文段，<strong>若对方同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。</strong></p></blockquote></li></ul><p>注意不管是发起连接会带有SYN字段，对请求的响应（同意建立连接）也会带上SYN<br>在带有SYN字段的TCP报文中，不能携带数据。</p><hr><ul><li><strong>ACK：确认序号</strong><blockquote><p>仅当ACK=1时确认号(ack)字段才有效，当ACK=0时，确认号无效。TCP规定，在连接建立后所有的传送报文段都必须把ACK置1。</p></blockquote></li></ul><p>就是表示好的，可以，我知道了。。。</p><hr><ul><li><strong>FIN：看字母也知道是finish的意思吧</strong><blockquote><p>用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放连接。</p></blockquote></li></ul><p>这个字段在解除连接（四次挥手）的时候会用到。</p><hr><p>今天就先学到这里，明天结合上面的知识点解释一下三次握手和四次挥手的过程~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;客户端与服务端的通信与TCP连接&quot;&gt;&lt;a href=&quot;#客户端与服务端的通信与TCP连接&quot; class=&quot;headerlink&quot; title=&quot;客户端与服务端的通信与TCP连接&quot;&gt;&lt;/a&gt;客户端与服务端的通信与TCP连接&lt;/h3&gt;&lt;h4 id=&quot;1-客户端与服务端的通信过程&quot;&gt;&lt;a href=&quot;#1-客户端与服务端的通信过程&quot; class=&quot;headerlink&quot; title=&quot;1. 客户端与服务端的通信过程&quot;&gt;&lt;/a&gt;1. 客户端与服务端的通信过程&lt;/h4&gt;&lt;p&gt;当客户端想要跟服务端进行信息交互时，过程如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="计算机基础" scheme="https://twentyshaw.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="HTTP" scheme="https://twentyshaw.github.io/tags/HTTP/"/>
    
      <category term="计算机基础" scheme="https://twentyshaw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>记录</title>
    <link href="https://twentyshaw.github.io/2019/11/14/%E8%AE%B0%E5%BD%95/"/>
    <id>https://twentyshaw.github.io/2019/11/14/记录/</id>
    <published>2019-11-14T03:43:18.000Z</published>
    <updated>2019-11-14T03:48:04.143Z</updated>
    
    <content type="html"><![CDATA[<h3 id="像是自虐一样，我已经打开cj那篇博客不下三次了。"><a href="#像是自虐一样，我已经打开cj那篇博客不下三次了。" class="headerlink" title="像是自虐一样，我已经打开cj那篇博客不下三次了。"></a>像是自虐一样，我已经打开cj那篇博客不下三次了。</h3><p>每当生活变得不如意的时候，当我的心情郁闷得不到疏解的时候，我总喜欢看看篇博客，让心情变得更糟糕一点。</p><a id="more"></a><p>那是关于他的，我的他。但是cj写这篇博客的时候他还不是我的。<br>那时还在大四，大学即将毕业，在准备来日本的材料。我觉得一切都还有希望。<br>cj把链接发给我让我看看，戏虐的问我看完什么感受。<br>难过吗？<br>我说，嗯，难过得想下去跑圈。<br>可是当时我并不怎么难过，至少不如现在难过。只是有点怅然若失，好像我奋力想抓住的东西，其实连它的影子都没有够到过。<br>当时我发了一条朋友圈：<br>「波罗叹了口气，他为自己不再年轻感到高兴」<br>我也是，为自己不再像十几岁那样固执感到高兴。</p><p>可是现在，在我真真切切的感受过他的一切，他手指的冰凉，怀抱的温暖，在经历过耳鬓厮磨过后，再来看那些句子，每个字都好像嘲笑。<br>我终究还是得到了他。<br>但他那些过往，他从六岁到二十岁喜欢念念不忘的姑娘，喝醉酒情绪崩溃时想的那个姑娘，是以一种怎样的形态存在在他的脑海里呢。<br>明明我也那些过去的时间里，但是为什么他总是说<br>是吗，记不清了欸</p><p>我太贪心了。<br>想占有他的全部这种想法太贪心了。吃到了糖连装糖的漂亮盒子也想收藏。</p><p>我觉得生活真的糟糕透了，<br>所以一次又一次打开那些文字，让自己被撕裂然后又自己愈合。<br>像是自虐一样。<br>连同其他伤口一起。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;像是自虐一样，我已经打开cj那篇博客不下三次了。&quot;&gt;&lt;a href=&quot;#像是自虐一样，我已经打开cj那篇博客不下三次了。&quot; class=&quot;headerlink&quot; title=&quot;像是自虐一样，我已经打开cj那篇博客不下三次了。&quot;&gt;&lt;/a&gt;像是自虐一样，我已经打开cj那篇博客不下三次了。&lt;/h3&gt;&lt;p&gt;每当生活变得不如意的时候，当我的心情郁闷得不到疏解的时候，我总喜欢看看篇博客，让心情变得更糟糕一点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常" scheme="https://twentyshaw.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="他" scheme="https://twentyshaw.github.io/tags/%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题3</title>
    <link href="https://twentyshaw.github.io/2019/11/12/JS%E4%BB%A3%E7%A0%81%E9%A2%983/"/>
    <id>https://twentyshaw.github.io/2019/11/12/JS代码题3/</id>
    <published>2019-11-12T13:00:33.000Z</published>
    <updated>2019-11-12T13:02:44.227Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最大差值"><a href="#最大差值" class="headerlink" title="最大差值"></a>最大差值</h3><p>给定一个未排序的数列，找到此数列在已排序状态下的两个相邻值的最大差值，少于两个值时返回0。例如：给定数列 [1,3,2,0,1,6,8] 则 最大差值为3。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function differ(arr)&#123;</span><br><span class="line">if (arr.length&lt;2) return 0</span><br><span class="line">arr.sort(function(a,b)&#123;</span><br><span class="line">return a-b</span><br><span class="line">&#125;)</span><br><span class="line">var maxDiffer = 0</span><br><span class="line">for (var i = 0; i &lt; arr.length-1; i++) &#123;</span><br><span class="line">if (arr[i+1] - arr[i] &gt; maxDiffer) &#123;</span><br><span class="line">maxDiffer = arr[i+1] - arr[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return maxDiffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到了数组方法sort()，复习一下：<br><code>arr.sort()</code></p><ul><li>该操作将arr排序后返回。原数组改变，返回的是排序后的数组。</li><li>可以接受一个函数作为参数，不传参的情况下将元素转换为字符串，然后比较它们的UTF-16代码单元值序列</li><li>传入一个函数的情况下：按照该函数指定的方法对arr进行排序。<br>  函数接受两个参数：a，b<br>  <strong>如果函数的返回值小于0，那么a排在b的前面，</strong><br>  <strong>如果函数的返回值等于0，那么a，b保持不动</strong><br>  <strong>如果函数的返回值大于0，那么a排在b的后面</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;最大差值&quot;&gt;&lt;a href=&quot;#最大差值&quot; class=&quot;headerlink&quot; title=&quot;最大差值&quot;&gt;&lt;/a&gt;最大差值&lt;/h3&gt;&lt;p&gt;给定一个未排序的数列，找到此数列在已排序状态下的两个相邻值的最大差值，少于两个值时返回0。例如：给定数列 [1,3,2,0,1,6,8] 则 最大差值为3。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="数组" scheme="https://twentyshaw.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议学习笔记(1)</title>
    <link href="https://twentyshaw.github.io/2019/11/11/HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://twentyshaw.github.io/2019/11/11/HTTP协议学习笔记-1/</id>
    <published>2019-11-11T05:48:25.000Z</published>
    <updated>2019-11-14T03:45:14.626Z</updated>
    
    <content type="html"><![CDATA[<p>先来看看MDN给出的定义：</p><blockquote><p>超文本传输​​协议（HTTP）是一个用于传输超媒体文档（例如 HTML）的应用层协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。<a id="more"></a>HTTP 遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP 是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 TCP/IP 层，但可以在任何可靠的传输层上使用；也就是说，不像 UDP，它是一个不会静默丢失消息的协议。</p></blockquote><p>其中涉及到的几个关键点：<br><strong>1. 超媒体文档</strong><br><strong>2. 应用层协议</strong><br><strong>3. 作用：客户端与服务端的通信</strong><br><strong>4. 无状态协议</strong><br><strong>5. TCP/IP 层</strong></p><h3 id="1-超媒体文档"><a href="#1-超媒体文档" class="headerlink" title="1. 超媒体文档"></a>1. 超媒体文档</h3><p>Web上的信息不同于我们平时看到的普通文本组成的线性信息，它是非线性的，<strong>超文本文件（hypertext）</strong>之间可以通过超链接来互相跳转。一个超文本文件就叫做一个网页。<br>Web上的信息不光只有超文本文件，还包括语音，图形，动画等。这些信息之间也可以由超链接互相连接，它们共同组成了<strong>超媒体文件（hypermedia）</strong>。</p><h3 id="2-应用层协议"><a href="#2-应用层协议" class="headerlink" title="2. 应用层协议"></a>2. 应用层协议</h3><p>互联网的实现，从上至下大致分为：<br><img src="https://upload-images.jianshu.io/upload_images/5426662-97d01324e4503360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>实体层靠近硬件，应用层靠近用户。<br>每一层为了完成自己特定的功能都要遵从一个规则，这个规则就称为协议。<br>应用层收到来自传输层的数据以后，要进行解读。由于传输层传过来的数据是各式各样的，比如有网页，文件，Email等。</p><blockquote><p><strong>“应用层”的作用，就是规定应用程序的数据格式。</strong></p></blockquote><p>想要合理的解读出这些数据，就需要根据不同的规则来解读。<br>HTTP就是其中一种规则，用来解读HTML这样的网络资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来看看MDN给出的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;超文本传输​​协议（HTTP）是一个用于传输超媒体文档（例如 HTML）的应用层协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="计算机基础" scheme="https://twentyshaw.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="HTTP" scheme="https://twentyshaw.github.io/tags/HTTP/"/>
    
      <category term="计算机基础" scheme="https://twentyshaw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题2</title>
    <link href="https://twentyshaw.github.io/2019/11/11/JS%E4%BB%A3%E7%A0%81%E9%A2%982/"/>
    <id>https://twentyshaw.github.io/2019/11/11/JS代码题2/</id>
    <published>2019-11-11T01:31:07.000Z</published>
    <updated>2019-11-11T01:32:56.054Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现千分位格式化"><a href="#实现千分位格式化" class="headerlink" title="实现千分位格式化"></a>实现千分位格式化</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function th(n)&#123;</span><br><span class="line">if (n&lt;1000) return</span><br><span class="line">var arr = n.toString().split(&apos;&apos;).reverse()</span><br><span class="line">var result = []</span><br><span class="line">var count = 0</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">result.unshift(arr[i])</span><br><span class="line">if (count&lt;arr.length-1 &amp;&amp; ++count % 3 === 0) &#123;</span><br><span class="line">result.unshift(&apos;,&apos;)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">return result.join(&apos;&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要注意判断count的时候限定count的大小</strong><br>如果不写<code>count&lt;arr.length-1</code>的话，当n为六位数时，会在第六位前面也加上一个“，”如：<br><img src="https://upload-images.jianshu.io/upload_images/5426662-b4e8bb82411c16d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实现千分位格式化&quot;&gt;&lt;a href=&quot;#实现千分位格式化&quot; class=&quot;headerlink&quot; title=&quot;实现千分位格式化&quot;&gt;&lt;/a&gt;实现千分位格式化&lt;/h3&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="数组" scheme="https://twentyshaw.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题1</title>
    <link href="https://twentyshaw.github.io/2019/11/10/JS%E4%BB%A3%E7%A0%81%E9%A2%981/"/>
    <id>https://twentyshaw.github.io/2019/11/10/JS代码题1/</id>
    <published>2019-11-10T05:22:28.000Z</published>
    <updated>2019-11-11T01:33:09.479Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）"><a href="#接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）" class="headerlink" title="接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）"></a>接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）</h3><a id="more"></a><h4 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1. 递归法"></a>1. 递归法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function output(m,n)&#123;</span><br><span class="line">let result = []</span><br><span class="line">if (m === 0) &#123;</span><br><span class="line">return result</span><br><span class="line">&#125;else&#123;</span><br><span class="line">result.unshift(n)</span><br><span class="line">return output(--m,n).concat(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用数组方法 <code>unshift()</code>来添加数组成员</li><li>使用数组方法 <code>concat()</code>来本轮结果与递归产生的数组</li></ul><h4 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2. Array.from()"></a>2. Array.from()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function output(m,n)&#123;</span><br><span class="line">return Array.from(&#123;length:m&#125;,v=&gt;n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6的Array.from()方法，它可将两类对象转化为数组：</p><ul><li>类似数组的对象：最本质的特征就是该对象要拥有<code>length</code>属性</li><li>可遍历的对象<br>Array.from()可以接受两个参数：</li><li>第一个参数是想要转成数组的对象</li><li>第二个参数是一个map方法。<br>与数组的map方法一致，第一个参数是数组成员→item，第二个参数（可省略）是数组的索引index，第三个参数（可省略）是数组本身</li></ul><p>基于第一个参数生成一个数组后，如果存在第二个参数，就对该数组进行map操作，并将map操作后的数组作为结果返回。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）&quot;&gt;&lt;a href=&quot;#接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）&quot; class=&quot;headerlink&quot; title=&quot;接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）&quot;&gt;&lt;/a&gt;接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）&lt;/h3&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="数组" scheme="https://twentyshaw.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>始まるんじゃない 始めるんだぜ</title>
    <link href="https://twentyshaw.github.io/2019/11/08/%E5%A7%8B%E3%81%BE%E3%82%8B%E3%82%93%E3%81%98%E3%82%83%E3%81%AA%E3%81%84-%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%93%E3%81%A0%E3%81%9Chexo-new-page-tag/"/>
    <id>https://twentyshaw.github.io/2019/11/08/始まるんじゃない-始めるんだぜhexo-new-page-tag/</id>
    <published>2019-11-08T09:32:00.000Z</published>
    <updated>2019-11-08T10:53:05.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="好像有过很多开始，但最后都无疾而终"><a href="#好像有过很多开始，但最后都无疾而终" class="headerlink" title="好像有过很多开始，但最后都无疾而终"></a>好像有过很多开始，但最后都无疾而终</h3><p>像被碌碌无为的日常吞没了一样，让人察觉不到自己的改变</p><a id="more"></a><p>以为自己还是曾经的自己，所以从不思考，不深究<br>当现在<br>当这个疲惫和失望交织的十月过去时<br>当虚度的光阴以“失败”的形象强势的出现在眼前的时候<br>才惊醒过来，原来不一样了<br>人是怎么废掉的<br>不是失去目标的时候<br>不是停止努力的时候<br>而是不再思考<br>思考是很累的事情<br>思考会让人认识到很多残忍的真相的存在<br>所以逃避是舒服的<br>只要不思考，就可以当作现在和以前一样<br>然后盲目愉悦的在生活的泥沼中越陷愈深</p><p>也不是完全没有警醒过<br>可是意志一旦被舒服的泥沼拉住时，是很难拔出来的</p><p>但还是要拔。<br>总羡慕过去的自己还是不太舒服<br>并且当这羡慕演变为嫉妒时，就总想做点什么来宣泄这些失意和愤怒<br>人不应该越来越差</p><p>所以<br>这个博客，是一个成长记录<br>也是我的自我救赎</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;好像有过很多开始，但最后都无疾而终&quot;&gt;&lt;a href=&quot;#好像有过很多开始，但最后都无疾而终&quot; class=&quot;headerlink&quot; title=&quot;好像有过很多开始，但最后都无疾而终&quot;&gt;&lt;/a&gt;好像有过很多开始，但最后都无疾而终&lt;/h3&gt;&lt;p&gt;像被碌碌无为的日常吞没了一样，让人察觉不到自己的改变&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常" scheme="https://twentyshaw.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="起点" scheme="https://twentyshaw.github.io/tags/%E8%B5%B7%E7%82%B9/"/>
    
  </entry>
  
</feed>
