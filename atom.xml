<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Syou</title>
  
  <subtitle>乌鸦为什么像写字台</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://twentyshaw.github.io/"/>
  <updated>2019-12-09T04:50:33.825Z</updated>
  <id>https://twentyshaw.github.io/</id>
  
  <author>
    <name>Syou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何将一个JavaScript数组打乱顺序</title>
    <link href="https://twentyshaw.github.io/2019/12/09/%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AA-JavaScript-%E6%95%B0%E7%BB%84%E6%89%93%E4%B9%B1%E9%A1%BA%E5%BA%8F/"/>
    <id>https://twentyshaw.github.io/2019/12/09/如何将一个-JavaScript-数组打乱顺序/</id>
    <published>2019-12-09T04:47:16.000Z</published>
    <updated>2019-12-09T04:50:33.825Z</updated>
    
    <content type="html"><![CDATA[<p>当我们想将现有的数组打乱顺序，有两个方法：</p><h3 id="1-Array-prototype-sort"><a href="#1-Array-prototype-sort" class="headerlink" title="1.  Array.prototype.sort()"></a>1.  Array.prototype.sort()</h3><p>数组的sort()方法</p><blockquote><p>用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的。</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,&apos;hello&apos;,&apos;bye&apos;,6,8,&apos;yes&apos;];</span><br><span class="line">arr.sort(function()&#123;</span><br><span class="line">return Math.random()-0.5</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>sort()方法如果指定了一个函数，那么会按照这个函数的返回值来对数组进行排序：</p><ul><li>如果返回值大于0，那么被比较的相邻两个数a和b，a会排到b的后面，</li><li>如果返回值等于0，那么a和b的位置不变</li><li>如果返回值小于0，那么a会排到b的前面。</li></ul><p>但是，用sort()方法不能实现真正意义上的完全乱序（<a href="https://www.zhihu.com/question/68330851/answer/266506621" target="_blank" rel="noopener">如何将一个 JavaScript 数组打乱顺序？ - Lucas HC的回答 - 知乎</a>），要实现完全乱序，需要用到 Fisher–Yates shuffle 洗牌算法。</p><h3 id="2-Fisher–Yates-shuffle-洗牌算法"><a href="#2-Fisher–Yates-shuffle-洗牌算法" class="headerlink" title="2.  Fisher–Yates shuffle 洗牌算法"></a>2.  Fisher–Yates shuffle 洗牌算法</h3><p>该方法就是每次在数组中随机产生一个位置，依次将数组中的每一项与该次产生的随机位置上的元素交换位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function shuffle(arr)&#123;</span><br><span class="line">var l = arr.length</span><br><span class="line">var index, temp</span><br><span class="line">while(l&gt;0)&#123;</span><br><span class="line">index = Math.floor(Math.random()*l)</span><br><span class="line">temp = arr[l-1]</span><br><span class="line">arr[l-1] = arr[index]</span><br><span class="line">arr[index] = temp</span><br><span class="line">l--</span><br><span class="line">&#125;</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们想将现有的数组打乱顺序，有两个方法：&lt;/p&gt;
&lt;h3 id=&quot;1-Array-prototype-sort&quot;&gt;&lt;a href=&quot;#1-Array-prototype-sort&quot; class=&quot;headerlink&quot; title=&quot;1.  Array.prototype.sort()&quot;&gt;&lt;/a&gt;1.  Array.prototype.sort()&lt;/h3&gt;&lt;p&gt;数组的sort()方法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="算法" scheme="https://twentyshaw.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="数组" scheme="https://twentyshaw.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="算法" scheme="https://twentyshaw.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="技巧" scheme="https://twentyshaw.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题14</title>
    <link href="https://twentyshaw.github.io/2019/12/08/JS%E4%BB%A3%E7%A0%81%E9%A2%9814/"/>
    <id>https://twentyshaw.github.io/2019/12/08/JS代码题14/</id>
    <published>2019-12-08T05:03:18.000Z</published>
    <updated>2019-12-08T05:09:33.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现类似getElementsByClassName-的功能"><a href="#实现类似getElementsByClassName-的功能" class="headerlink" title="实现类似getElementsByClassName 的功能"></a>实现类似getElementsByClassName 的功能</h3><h4 id="自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点。不允许使用原生提供的getElementsByClassName，querySelectorAll等原生提供DOM查找函数。"><a href="#自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点。不允许使用原生提供的getElementsByClassName，querySelectorAll等原生提供DOM查找函数。" class="headerlink" title="自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点。不允许使用原生提供的getElementsByClassName，querySelectorAll等原生提供DOM查找函数。"></a>自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点。不允许使用原生提供的getElementsByClassName，querySelectorAll等原生提供DOM查找函数。</h4><a id="more"></a><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function findClass(node,name)&#123;</span><br><span class="line">var nodes</span><br><span class="line">if(node)&#123;</span><br><span class="line">nodes = node.children</span><br><span class="line">&#125;else&#123; //没有传节点的情况下，就搜索整篇文档内的元素</span><br><span class="line">nodes = document.getElementsByTagName(&apos;*&apos;) </span><br><span class="line">&#125;</span><br><span class="line">var classes</span><br><span class="line">var result = []</span><br><span class="line">for (var i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">classes = nodes[i].className.split(&apos; &apos;) //一个元素可能拥有多个classname，被空格隔开</span><br><span class="line">if (classes.indexOf(name) !== -1) &#123;</span><br><span class="line">result.push(nodes[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是用到了原生查找函数：<code>document.getElementsByTagName</code>，不知道有没有不能这个函数能获取所有元素节点的方法</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实现类似getElementsByClassName-的功能&quot;&gt;&lt;a href=&quot;#实现类似getElementsByClassName-的功能&quot; class=&quot;headerlink&quot; title=&quot;实现类似getElementsByClassName 的功能&quot;&gt;&lt;/a&gt;实现类似getElementsByClassName 的功能&lt;/h3&gt;&lt;h4 id=&quot;自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点。不允许使用原生提供的getElementsByClassName，querySelectorAll等原生提供DOM查找函数。&quot;&gt;&lt;a href=&quot;#自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点。不允许使用原生提供的getElementsByClassName，querySelectorAll等原生提供DOM查找函数。&quot; class=&quot;headerlink&quot; title=&quot;自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点。不允许使用原生提供的getElementsByClassName，querySelectorAll等原生提供DOM查找函数。&quot;&gt;&lt;/a&gt;自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点。不允许使用原生提供的getElementsByClassName，querySelectorAll等原生提供DOM查找函数。&lt;/h4&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="DOM" scheme="https://twentyshaw.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题13</title>
    <link href="https://twentyshaw.github.io/2019/12/08/JS%E4%BB%A3%E7%A0%81%E9%A2%9813/"/>
    <id>https://twentyshaw.github.io/2019/12/08/JS代码题13/</id>
    <published>2019-12-08T05:03:02.000Z</published>
    <updated>2019-12-08T05:08:56.711Z</updated>
    
    <content type="html"><![CDATA[<h3 id="随机生成指定长度的字符串"><a href="#随机生成指定长度的字符串" class="headerlink" title="随机生成指定长度的字符串"></a>随机生成指定长度的字符串</h3><h4 id="实现一个算法，随机生成指制定长度的字符串。"><a href="#实现一个算法，随机生成指制定长度的字符串。" class="headerlink" title="实现一个算法，随机生成指制定长度的字符串。"></a>实现一个算法，随机生成指制定长度的字符串。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如给定 长度 8  输出 4ldkfg9j</span><br></pre></td></tr></table></figure><a id="more"></a><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function str(n)&#123;</span><br><span class="line">var str = &quot;&quot;</span><br><span class="line">var base = &quot;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz123456789&quot;</span><br><span class="line">    //var i = Math.floor(Math.random()*Math.pow(10,n))</span><br><span class="line">    //这种方法只能取到0-9位的数字 pass</span><br><span class="line">    for(let i = 0; i&lt;n; i++)&#123;</span><br><span class="line">      var index = Math.floor(Math.random()*base.length) </span><br><span class="line">      //因为Math.random()产生的数小于1，</span><br><span class="line">      //所以它乘以base.length的结果在base的范围以内，并且可以取到所有字母</span><br><span class="line">      str = str + base.charAt(index)</span><br><span class="line">    &#125;</span><br><span class="line">    return str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>base是手写的，有什么好的生成方法吗?</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;随机生成指定长度的字符串&quot;&gt;&lt;a href=&quot;#随机生成指定长度的字符串&quot; class=&quot;headerlink&quot; title=&quot;随机生成指定长度的字符串&quot;&gt;&lt;/a&gt;随机生成指定长度的字符串&lt;/h3&gt;&lt;h4 id=&quot;实现一个算法，随机生成指制定长度的字符串。&quot;&gt;&lt;a href=&quot;#实现一个算法，随机生成指制定长度的字符串。&quot; class=&quot;headerlink&quot; title=&quot;实现一个算法，随机生成指制定长度的字符串。&quot;&gt;&lt;/a&gt;实现一个算法，随机生成指制定长度的字符串。&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;比如给定 长度 8  输出 4ldkfg9j&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="字符串" scheme="https://twentyshaw.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>用JS随机获取元素的方法</title>
    <link href="https://twentyshaw.github.io/2019/12/08/%E7%94%A8JS%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://twentyshaw.github.io/2019/12/08/用JS随机获取元素的方法/</id>
    <published>2019-12-08T04:50:57.000Z</published>
    <updated>2019-12-09T04:52:42.896Z</updated>
    
    <content type="html"><![CDATA[<p>今天做题的时候用到了<code>Math.random()</code>。所以来总结一下利用它来随机获取元素的技巧。</p><h3 id="1-获取指定范围内的随机数"><a href="#1-获取指定范围内的随机数" class="headerlink" title="1. 获取指定范围内的随机数"></a>1. 获取指定范围内的随机数</h3><p>当我们需要获取指定范围(min,max)内的整数的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getNum(min,max)&#123;</span><br><span class="line">return Math.floor(Math.random()*(max-min+1)) + min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>max-min</code>还要加个1是为了保证能取到max</li><li>取整后加min是因为下限是min，不加的话就是从0开始了</li></ul><h3 id="2-随机获取数组中的元素"><a href="#2-随机获取数组中的元素" class="headerlink" title="2. 随机获取数组中的元素"></a>2. 随机获取数组中的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getItem(arr)&#123;</span><br><span class="line">var i = Math.floor(Math.random()*arr.length)</span><br><span class="line">return arr[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Math.random()</code>直接乘以<code>arr.length</code>而不是<code>arr.length-1</code>，是因为<code>Math.random()</code>产生一个小于1的小数，它乘以<code>arr.length</code>肯定得到在0到<code>arr.length-1</code>之间（包含arr.length-1）的某个数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天做题的时候用到了&lt;code&gt;Math.random()&lt;/code&gt;。所以来总结一下利用它来随机获取元素的技巧。&lt;/p&gt;
&lt;h3 id=&quot;1-获取指定范围内的随机数&quot;&gt;&lt;a href=&quot;#1-获取指定范围内的随机数&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="技巧" scheme="https://twentyshaw.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题12(其实是数学题)</title>
    <link href="https://twentyshaw.github.io/2019/12/06/JS%E4%BB%A3%E7%A0%81%E9%A2%9812/"/>
    <id>https://twentyshaw.github.io/2019/12/06/JS代码题12/</id>
    <published>2019-12-06T01:14:02.000Z</published>
    <updated>2019-12-06T01:18:02.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不借助临时变量，进行两个整数的交换"><a href="#不借助临时变量，进行两个整数的交换" class="headerlink" title="不借助临时变量，进行两个整数的交换"></a>不借助临时变量，进行两个整数的交换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入 a = 2, b = 4 输出 a = 4, b =2</span><br></pre></td></tr></table></figure><a id="more"></a><p>就是数学学的括号运算的思想：a=a+(b-a)<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function swap(a,b)&#123;</span><br><span class="line">b = b - a</span><br><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">return [a,b] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不借助临时变量，进行两个整数的交换&quot;&gt;&lt;a href=&quot;#不借助临时变量，进行两个整数的交换&quot; class=&quot;headerlink&quot; title=&quot;不借助临时变量，进行两个整数的交换&quot;&gt;&lt;/a&gt;不借助临时变量，进行两个整数的交换&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入 a = 2, b = 4 输出 a = 4, b =2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题11</title>
    <link href="https://twentyshaw.github.io/2019/12/01/JS%E4%BB%A3%E7%A0%81%E9%A2%9811/"/>
    <id>https://twentyshaw.github.io/2019/12/01/JS代码题11/</id>
    <published>2019-12-01T05:02:40.000Z</published>
    <updated>2019-12-08T05:07:55.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="统计一个字符串出现最多的字母"><a href="#统计一个字符串出现最多的字母" class="headerlink" title="统计一个字符串出现最多的字母"></a>统计一个字符串出现最多的字母</h3><h4 id="给出一段英文连续的英文字符窜，找出重复出现次数最多的字母"><a href="#给出一段英文连续的英文字符窜，找出重复出现次数最多的字母" class="headerlink" title="给出一段英文连续的英文字符窜，找出重复出现次数最多的字母"></a>给出一段英文连续的英文字符窜，找出重复出现次数最多的字母</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入 ： afjghdfraaaasdenas </span><br><span class="line"> </span><br><span class="line">输出 ： a</span><br></pre></td></tr></table></figure><a id="more"></a><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function findMaxDuplicateChar(str)&#123;</span><br><span class="line">var arr = str.split(&apos;&apos;)</span><br><span class="line">var holder = &#123;&#125;</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">if(holder.hasOwnProperty(arr[i]))&#123;</span><br><span class="line">holder[arr[i]]++</span><br><span class="line">&#125;else&#123;</span><br><span class="line">holder[arr[i]] = 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var maxChar = &quot;&quot;</span><br><span class="line">var maxDup = 1</span><br><span class="line">for(var j in holder)&#123;</span><br><span class="line">if (holder[j] &gt; maxDup) &#123;</span><br><span class="line">maxChar = j</span><br><span class="line">maxDup = holder[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return maxChar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;统计一个字符串出现最多的字母&quot;&gt;&lt;a href=&quot;#统计一个字符串出现最多的字母&quot; class=&quot;headerlink&quot; title=&quot;统计一个字符串出现最多的字母&quot;&gt;&lt;/a&gt;统计一个字符串出现最多的字母&lt;/h3&gt;&lt;h4 id=&quot;给出一段英文连续的英文字符窜，找出重复出现次数最多的字母&quot;&gt;&lt;a href=&quot;#给出一段英文连续的英文字符窜，找出重复出现次数最多的字母&quot; class=&quot;headerlink&quot; title=&quot;给出一段英文连续的英文字符窜，找出重复出现次数最多的字母&quot;&gt;&lt;/a&gt;给出一段英文连续的英文字符窜，找出重复出现次数最多的字母&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入 ： afjghdfraaaasdenas &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出 ： a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="数组" scheme="https://twentyshaw.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="字符串" scheme="https://twentyshaw.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题10</title>
    <link href="https://twentyshaw.github.io/2019/12/01/JS%E4%BB%A3%E7%A0%81%E9%A2%9810/"/>
    <id>https://twentyshaw.github.io/2019/12/01/JS代码题10/</id>
    <published>2019-12-01T05:02:23.000Z</published>
    <updated>2019-12-08T05:06:21.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><a id="more"></a><h4 id="1-简易版"><a href="#1-简易版" class="headerlink" title="1. 简易版"></a>1. 简易版</h4><p><strong>不考虑引用类型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function uniq(arr) &#123;</span><br><span class="line">    var myarr = []</span><br><span class="line">    var flag = true</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (myarr.indexOf(arr[i]) === -1) &#123;</span><br><span class="line">        if (arr[i] !== arr[i]) &#123; //判断该元素是否为NaN，因为indexOf(NaN)会返回-1</span><br><span class="line">          if (flag) &#123;</span><br><span class="line">            myarr.push(arr[i])</span><br><span class="line">            flag = false</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          myarr.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return myarr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-复杂版"><a href="#2-复杂版" class="headerlink" title="2. 复杂版"></a>2. 复杂版</h4><p><strong>当数组元素为引用类型的时候，不能用indexOf()来判断。因为他总是会返回-1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">function uniq(arr) &#123;</span><br><span class="line">    var flag = true</span><br><span class="line">    var myArr = []</span><br><span class="line">    var myObj = []</span><br><span class="line">    for(let i=0;i&lt;arr.length; i++)&#123;</span><br><span class="line">    if (arr[i] !== arr[i]) &#123;</span><br><span class="line">    if (!flag) &#123;</span><br><span class="line">    arr.splice(i,1)</span><br><span class="line">    i-- </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    flag = false</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;else if(Array.isArray(arr[i]))&#123; </span><br><span class="line">    myArr.push(arr[i])</span><br><span class="line">    if (myArr.length&gt;1) &#123;</span><br><span class="line">    for (let j = 0; j &lt; myArr.length; j++) &#123;</span><br><span class="line">    for (let m = myArr.length-1; m &gt; j ; m--) &#123;</span><br><span class="line">    var arrResult = eqArr(myArr[j],myArr[m])</span><br><span class="line">    if (arrResult) &#123;</span><br><span class="line">myArr.splice(m,1) // 这里删除元素后，m不用减1，是因为本身m就是最末尾的元素，删除它不会影响序号</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">arr.splice(i,1)</span><br><span class="line">    i--</span><br><span class="line">    &#125;else if(arr[i] !== null &amp;&amp; typeof arr[i] === &quot;object&quot;)&#123;</span><br><span class="line">    myObj.push(arr[i])</span><br><span class="line">    if (myObj.length&gt;1) &#123;</span><br><span class="line">    for (let k = 0; k &lt; myObj.length; k++) &#123;</span><br><span class="line">    for (let n = myObj.length-1; n &gt; k; n--) &#123;</span><br><span class="line">var objResult = eqObj(myObj[k],myObj[n])</span><br><span class="line">if (objResult) &#123;</span><br><span class="line">myObj.splice(n,1)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  arr.splice(i,1)</span><br><span class="line">    i-- </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    if (arr.indexOf(arr[i]) !== arr.lastIndexOf(arr[i])) &#123;</span><br><span class="line">    arr.splice(i,1)</span><br><span class="line">    i--</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var result1 = arr.concat(myArr)</span><br><span class="line">    var result = result1.concat(myObj)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function eqObj(a,b)&#123;</span><br><span class="line">if (Object.keys(a).length !== Object.keys(b).length) &#123; //属性不一样多 直接可以判断为二者不相等</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">for(var i in a)&#123;</span><br><span class="line">if (b.hasOwnProperty(i)) &#123;</span><br><span class="line">if (a[i] !== b[i]) &#123;</span><br><span class="line">if (typeof a[i] === &quot;object&quot; &amp;&amp; typeof b[i] === &quot;object&quot;) &#123;</span><br><span class="line">if (Array.isArray(a[i]) &amp;&amp; Array.isArray(b[i])) &#123;</span><br><span class="line">if(!(eqArr(a[i],b[i]))) return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(!(eqObj(a[i],b[i]))) return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function eqArr(a,b)&#123;</span><br><span class="line">if (a.length !== b.length) &#123; //两数组长度不一样，直接判断为而这不相等</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">for (var i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">if (a[i] !== b[i]) &#123;</span><br><span class="line">if (typeof a[i] === &quot;object&quot; &amp;&amp; typeof b[i] === &quot;object&quot;) &#123;</span><br><span class="line">if (Array.isArray(a[i]) &amp;&amp; Array.isArray(b[i])) &#123;</span><br><span class="line">if(!(eqArr(a[i],b[i]))) return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(!(eqObj(a[i],b[i]))) return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法运用了递归。<br>注意在<code>eqArr()</code>函数（或<code>eqObj()</code>）的循环中不能有 <code>return true</code>的语句。因为这样会终止循环，导致<code>index = i</code>以后的元素都不能被比较。<br>有可能是我想得太复杂了，写得真的很多。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组去重&quot;&gt;&lt;a href=&quot;#数组去重&quot; class=&quot;headerlink&quot; title=&quot;数组去重&quot;&gt;&lt;/a&gt;数组去重&lt;/h3&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="数组" scheme="https://twentyshaw.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题9</title>
    <link href="https://twentyshaw.github.io/2019/11/28/JS%E4%BB%A3%E7%A0%81%E9%A2%989/"/>
    <id>https://twentyshaw.github.io/2019/11/28/JS代码题9/</id>
    <published>2019-11-28T02:02:22.000Z</published>
    <updated>2019-11-28T02:04:47.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断一个单词-包含数字-是否是回文"><a href="#判断一个单词-包含数字-是否是回文" class="headerlink" title="判断一个单词(包含数字)是否是回文"></a>判断一个单词(包含数字)是否是回文</h3><ul><li><strong>回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider .</strong></li><li><strong>如果一个非负数左右完全对应，则该数是回文数，例如：121,22等。<br>如果一个负数的绝对值左右完全对应，也是回文数，例如：-121,-22等。</strong><a id="more"></a>用数组的<code>reverse()</code>方法可以很容易的实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function find(str)&#123;</span><br><span class="line">var arr = str.split(&apos;&apos;)</span><br><span class="line">var result</span><br><span class="line">if (arr[0] === &apos;-&apos;) &#123; //判断是否为负数</span><br><span class="line">var mark = arr.shift()</span><br><span class="line">arr.reverse().unshift(mark) //注意unshfit返回的是数组长度，所以不要和join写在一起</span><br><span class="line">result = arr.join(&apos;&apos;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">result = arr.reverse().join(&apos;&apos;)</span><br><span class="line">&#125;</span><br><span class="line">return str === result?true:false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;判断一个单词-包含数字-是否是回文&quot;&gt;&lt;a href=&quot;#判断一个单词-包含数字-是否是回文&quot; class=&quot;headerlink&quot; title=&quot;判断一个单词(包含数字)是否是回文&quot;&gt;&lt;/a&gt;判断一个单词(包含数字)是否是回文&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider .&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果一个非负数左右完全对应，则该数是回文数，例如：121,22等。&lt;br&gt;如果一个负数的绝对值左右完全对应，也是回文数，例如：-121,-22等。&lt;/strong&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="数组" scheme="https://twentyshaw.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题8</title>
    <link href="https://twentyshaw.github.io/2019/11/22/%E4%BB%A3%E7%A0%81%E9%A2%988/"/>
    <id>https://twentyshaw.github.io/2019/11/22/代码题8/</id>
    <published>2019-11-22T04:42:33.000Z</published>
    <updated>2019-11-28T02:05:49.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构处理"><a href="#数据结构处理" class="headerlink" title="数据结构处理"></a>数据结构处理</h3><h4 id="有一个祖先树状-json-对象，当一个人有一个儿子的时候，child-为对象，如果有多个儿子，child-为数组。请实现一个函数，找出这个家族中所有有多个儿子的人的名字（name），输出一个数组。"><a href="#有一个祖先树状-json-对象，当一个人有一个儿子的时候，child-为对象，如果有多个儿子，child-为数组。请实现一个函数，找出这个家族中所有有多个儿子的人的名字（name），输出一个数组。" class="headerlink" title="有一个祖先树状 json 对象，当一个人有一个儿子的时候，child 为对象，如果有多个儿子，child 为数组。请实现一个函数，找出这个家族中所有有多个儿子的人的名字（name），输出一个数组。"></a>有一个祖先树状 json 对象，当一个人有一个儿子的时候，child 为对象，如果有多个儿子，child 为数组。请实现一个函数，找出这个家族中所有有多个儿子的人的名字（name），输出一个数组。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let data = &#123;</span><br><span class="line">  name: &apos;jack&apos;,</span><br><span class="line">  child: [</span><br><span class="line">    &#123; name: &apos;jack1&apos; &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;jack2&apos;,</span><br><span class="line">      child: [&#123;</span><br><span class="line">        name: &apos;jack2-1&apos;,</span><br><span class="line">        child: &#123; name: &apos;jack2-1-1&apos; &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        name: &apos;jack2-2&apos;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;jack3&apos;,</span><br><span class="line">      child: &#123; name: &apos;jack3-1&apos; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用递归来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function fathers(data)&#123;</span><br><span class="line">var fathers = [] //数组要放在外面，不然递归的时候每次都会建一个新的出来</span><br><span class="line">function findFather(data)&#123;</span><br><span class="line">if (data.hasOwnProperty(&apos;child&apos;)) &#123; //先判断他有没有儿子</span><br><span class="line">if (data.child.length) &#123; //判断有几个儿子（是否是数组）</span><br><span class="line">fathers.push(data.name)</span><br><span class="line">for (var i = 0; i &lt; data.child.length; i++) &#123;</span><br><span class="line">findFather(data.child[i]) //递归每一个儿子</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">findFather(data.child) //递归仅有的一个儿子</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    findFather(data) //别忘了调用一次内部函数</span><br><span class="line">return fathers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据结构处理&quot;&gt;&lt;a href=&quot;#数据结构处理&quot; class=&quot;headerlink&quot; title=&quot;数据结构处理&quot;&gt;&lt;/a&gt;数据结构处理&lt;/h3&gt;&lt;h4 id=&quot;有一个祖先树状-json-对象，当一个人有一个儿子的时候，child-为对象，如果有多个儿子，ch
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="JSON" scheme="https://twentyshaw.github.io/tags/JSON/"/>
    
      <category term="数据结构" scheme="https://twentyshaw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题7——属性描述对象</title>
    <link href="https://twentyshaw.github.io/2019/11/19/JS%E4%BB%A3%E7%A0%81%E9%A2%987%E2%80%94%E2%80%94%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E5%AF%B9%E8%B1%A1/"/>
    <id>https://twentyshaw.github.io/2019/11/19/JS代码题7——属性描述对象/</id>
    <published>2019-11-19T07:00:04.000Z</published>
    <updated>2019-11-19T07:06:03.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据绑定最基本的实现"><a href="#数据绑定最基本的实现" class="headerlink" title="数据绑定最基本的实现"></a>数据绑定最基本的实现</h3><h4 id="实现一个方法，可以给-obj-所有的属性添加动态绑定事件，当属性值发生变化时会触发事件"><a href="#实现一个方法，可以给-obj-所有的属性添加动态绑定事件，当属性值发生变化时会触发事件" class="headerlink" title="实现一个方法，可以给 obj 所有的属性添加动态绑定事件，当属性值发生变化时会触发事件"></a>实现一个方法，可以给 obj 所有的属性添加动态绑定事件，当属性值发生变化时会触发事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  key_1: 1,</span><br><span class="line">  key_2: 2</span><br><span class="line">&#125;</span><br><span class="line">function func(key) &#123;</span><br><span class="line">  console.log(key + &apos; 的值发生改变：&apos; + this[key]);</span><br><span class="line">&#125;</span><br><span class="line">bindData(obj, func);</span><br><span class="line">obj.key_1 = 2; // 此时自动输出 &quot;key_1 的值发生改变：2&quot;</span><br><span class="line">obj.key_2 = 1; // 此时自动输出 &quot;key_2 的值发生改变：1&quot;</span><br></pre></td></tr></table></figure><p>实现bindData(obj, func)函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function bindData(obj, func)&#123;</span><br><span class="line">for(let key in obj)&#123;</span><br><span class="line">let value = obj[key]</span><br><span class="line">Object.defineProperty(obj,key,&#123;</span><br><span class="line">set:function(newValue)&#123;</span><br><span class="line">if (newValue !== value) &#123;</span><br><span class="line">                    this.value = newValue</span><br><span class="line">func.call(obj,key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">get:function()&#123;</span><br><span class="line">return this.value</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么点代码折磨了我一个中午<br>踩过的几个坑：<br><strong>1. 在遍历对象属性的时候用<code>for(var key in obj)</code></strong><br>这个地方是不能用var的，因为会导致你不管调用 <code>obj.key_1</code>还是<code>obj.key_2</code>他都只能打印出：<br><img src="https://upload-images.jianshu.io/upload_images/5426662-7e8f87cea73bb8e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>用<code>var</code>声明的那个<code>key</code>会保留在上层作用域，你在调用 <code>obj.key_1</code>触发<code>func.call(obj,key)</code>的时候，里面的<code>key</code>为循环遍历后最后赋给key的值，也就是本题中的<code>key_2</code></p><p><strong>2. this.value在赋值以前为undefined</strong><br>我的第一版代码是这么写的（是错的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function bindData(obj, func) &#123;</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">      set: function(newValue) &#123;</span><br><span class="line">        if (this.value !== newValue) &#123;</span><br><span class="line">          this.value = newValue;</span><br><span class="line">          func.call(obj, key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      get: function()&#123;</span><br><span class="line">        return this.value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法会导致<code>if (this.value !== newValue)</code>判断失效。因为这时的<code>this.value</code>为undefined，所以无论属性值是否发生变化，<code>func.call(obj,key)</code>都会被调用，如：<br><img src="https://upload-images.jianshu.io/upload_images/5426662-c35db38e8b8a6e69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这显然不符合题目要求的<strong>“当属性值发生变化时会触发事件”</strong>。<br>针对这个问题，需要学习一下<strong>属性描述对象</strong>：<code>Object.defineProperty()</code></p><h4 id="属性描述对象"><a href="#属性描述对象" class="headerlink" title="属性描述对象"></a>属性描述对象</h4><p>来自<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">MDN</a>的定义</p><blockquote><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， <strong>并返回这个对象</strong>。</p></blockquote><p>这个方法接受三个参数：</p><ul><li><strong>obj：要在其上定义属性的对象。</strong></li><li><strong>prop：要定义或修改的属性的名称。</strong></li><li><strong>descriptor：将被定义或修改的属性描述符。</strong><h4 id="属性描述符：descriptor"><a href="#属性描述符：descriptor" class="headerlink" title="属性描述符：descriptor"></a>属性描述符：descriptor</h4>属性描述符分为两种形式：<strong>数据描述符</strong>和<strong>存取描述符</strong>。</li></ul><p><strong>描述符必须是这两种形式之一；不能同时是两者。</strong></p><ul><li><p>数据描述符：一个具有值的属性，该值可能是可写的，也可能不是可写的。<br>它具有以下可选键值：<br><strong>value</strong>：该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。<strong>默认为 undefined。</strong><br><strong>writable</strong>：当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</p></li><li><p>存取描述符：由getter-setter函数对描述的属性。<br>它具有以下可选键值：<br><strong>get</strong>：取值函数。在对象调用属性的时候触发。<br><strong>set</strong>：存值函数。在给属性赋值的时候触发。</p></li></ul><p>以上这四个属性中，数据描述符的属性不能和存取描述符的属性同时存在：</p><blockquote><p><strong>如果一个描述符同时有(value或writable)和(get或set)关键字，将会产生一个异常。</strong></p></blockquote><p>除此之外，还有两个共同的属性：</p><ul><li><strong>configurable</strong>：当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</li><li><strong>enumerable</strong>：当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。</li></ul><p>以上为基本概念，结合这些基本概念本题中要注意的点有：</p><ul><li><code>Object.defineProperty()</code>方法中，this指向定义该属性的对象（不考虑继承关系）</li><li>用<code>Object.defineProperty()</code>修改属性之后，比如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  key: 1,</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(obj,&apos;key&apos;,&#123;</span><br><span class="line">set:function(newValue)&#123;</span><br><span class="line">            this.value = newValue</span><br><span class="line">&#125;,</span><br><span class="line">get:function()&#123;</span><br><span class="line">            return this.value</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>这时如果调用<code>obj.key</code>返回的值为undefined：<br><img src="https://upload-images.jianshu.io/upload_images/5426662-b92b6b27bf48d705.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>因为<code>obj.key</code>会触发取值函数，但取值函数返回的<code>this.value</code>为undefined。也就是说：<br><strong>修改属性的属性描述符过后，之前的属性值就不存在了。该属性是一个全新的属性。它的值取决于value（数据描述符）或者get函数的返回值（存取描述符）</strong><br>但是上面的例子，只要修改过后，给属性赋一次值，this.value就有值了（不为undefined）。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据绑定最基本的实现&quot;&gt;&lt;a href=&quot;#数据绑定最基本的实现&quot; class=&quot;headerlink&quot; title=&quot;数据绑定最基本的实现&quot;&gt;&lt;/a&gt;数据绑定最基本的实现&lt;/h3&gt;&lt;h4 id=&quot;实现一个方法，可以给-obj-所有的属性添加动态绑定事件，当属性值
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="对象" scheme="https://twentyshaw.github.io/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题6</title>
    <link href="https://twentyshaw.github.io/2019/11/18/JS%E4%BB%A3%E7%A0%81%E9%A2%986/"/>
    <id>https://twentyshaw.github.io/2019/11/18/JS代码题6/</id>
    <published>2019-11-18T05:59:04.000Z</published>
    <updated>2019-11-18T06:02:25.127Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><h4 id="请使用最基本的遍历来实现判断字符串-a-是否被包含在字符串-b-中，并返回第一次出现的位置（找不到返回-1）。"><a href="#请使用最基本的遍历来实现判断字符串-a-是否被包含在字符串-b-中，并返回第一次出现的位置（找不到返回-1）。" class="headerlink" title="请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。"></a>请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=&apos;34&apos;;b=&apos;1234567&apos;; // 返回 2</span><br><span class="line">a=&apos;35&apos;;b=&apos;1234567&apos;; // 返回 -1</span><br><span class="line">a=&apos;355&apos;;b=&apos;12354355&apos;; // 返回 5</span><br><span class="line">isContain(a,b);</span><br></pre></td></tr></table></figure><p>题目要求实现的功能其实就是String的indexOf()方法，所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isContain(strA,strB)&#123;</span><br><span class="line">return strB.indexOf(strA)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是题目要求<strong>“最基本的遍历来实现”</strong>，所以不能使用indexOf()方法。用遍历来实现的话:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function isContain(strA,strB)&#123;</span><br><span class="line">var arrA = strA.split(&apos;&apos;)</span><br><span class="line">var arrB = strB.split(&apos;&apos;)</span><br><span class="line">var flag,temp</span><br><span class="line">for(var j in arrB)&#123;</span><br><span class="line">if (arrA[0] === arrB[j]) &#123;</span><br><span class="line">temp = parseInt(j) //注意这里的j是一个字符串。。它居然是个字符串</span><br><span class="line">flag = true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var index = temp + 1</span><br><span class="line">for (var i = 1; i &lt; arrA.length; i++)&#123;</span><br><span class="line">if (arrA[i] !== arrB[index++]) &#123;</span><br><span class="line">flag = false</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (flag) &#123;</span><br><span class="line">return temp</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己在写这个代码的过程中犯了一个错误：</p><ul><li><strong>for(in)循环索引是字符串而不是整数。</strong>并且我不应该用for in循环来遍历一个数组。<br>所以代码最好改写成：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function isContain(strA,strB)&#123;</span><br><span class="line">var arrA = strA.split(&apos;&apos;)</span><br><span class="line">var arrB = strB.split(&apos;&apos;)</span><br><span class="line">var flag,temp</span><br><span class="line">for (var k = 0; k &lt; arrB.length; k++) &#123;</span><br><span class="line">if (arrB[k] === arrA[0]) &#123;</span><br><span class="line">temp = j</span><br><span class="line">flag = true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var index = temp + 1</span><br><span class="line">for (var i = 1; i &lt; arrA.length; i++)&#123;</span><br><span class="line">if (arrA[i] !== arrB[index++]) &#123;</span><br><span class="line">flag = false</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (flag) &#123;</span><br><span class="line">return temp</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>然后还有几个要注意的点：</li><li>用temp来记录匹配的起始位置</li><li>用flag来判断输出</li><li>最开始我想比较数组arrA和数组arrB的时候一直找不到好的方法。我试过外部遍历arrA然后在内部遍历arrB但是出错了。后来我发现我并不需要遍历arrB（我不需要拿到它的所有项目，也不需要它的length），我只要将arrA中的每一项与arrB的项依次对比就可以了。所以使用了arrB[index++]。（注意index的初始值为temp+1）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;字符串查找&quot;&gt;&lt;a href=&quot;#字符串查找&quot; class=&quot;headerlink&quot; title=&quot;字符串查找&quot;&gt;&lt;/a&gt;字符串查找&lt;/h3&gt;&lt;h4 id=&quot;请使用最基本的遍历来实现判断字符串-a-是否被包含在字符串-b-中，并返回第一次出现的位置（找不到返回-1
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="数组" scheme="https://twentyshaw.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="字符串" scheme="https://twentyshaw.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题5</title>
    <link href="https://twentyshaw.github.io/2019/11/18/JS%E4%BB%A3%E7%A0%81%E9%A2%985/"/>
    <id>https://twentyshaw.github.io/2019/11/18/JS代码题5/</id>
    <published>2019-11-18T01:20:55.000Z</published>
    <updated>2019-11-18T01:25:26.387Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="实现一个简单的虚拟-DOM-渲染"><a href="#实现一个简单的虚拟-DOM-渲染" class="headerlink" title="实现一个简单的虚拟 DOM 渲染"></a>实现一个简单的虚拟 DOM 渲染</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let domNode = &#123;</span><br><span class="line">  tagName: &apos;ul&apos;,</span><br><span class="line">  props: &#123; class: &apos;list&apos; &#125;,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    tagName: &apos;li&apos;,</span><br><span class="line">    children: [&apos;item1&apos;]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    tagName: &apos;li&apos;,</span><br><span class="line">    children: [&apos;item1&apos;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 构建一个 render 函数，将 domNode 对象渲染为 以下 dom</span><br><span class="line">&lt;ul class=&quot;list&quot;&gt;</span><br><span class="line">    &lt;li&gt;item1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;item2&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>实现render函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function render(domNode)&#123;</span><br><span class="line">if (!domNode) return </span><br><span class="line">var $el</span><br><span class="line">if (typeof domNode === &apos;object&apos;) &#123;</span><br><span class="line">$el = document.createElement(domNode.tagName)</span><br><span class="line">if (domNode.hasOwnProperty(&apos;props&apos;)) &#123;</span><br><span class="line">for(var key in domNode.props)&#123;</span><br><span class="line">$el.setAttribute(key,domNode.props[key])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (domNode.hasOwnProperty(&apos;children&apos;)) &#123;</span><br><span class="line">domNode.children.forEach(child=&gt;&#123;</span><br><span class="line">var $child = render(child)</span><br><span class="line">$el.append($child)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$el = document.createTextNode(domNode)</span><br><span class="line">&#125;</span><br><span class="line">    //document.documentElement.append($el) 如果希望直接渲染到页面上</span><br><span class="line">return $el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要用到了DOM API 和递归</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;实现一个简单的虚拟-DOM-渲染&quot;&gt;&lt;a href=&quot;#实现一个简单的虚拟-DOM-渲染&quot; class=&quot;headerlink&quot; title=&quot;实现一个简单的虚拟 DOM 渲染&quot;&gt;&lt;/a&gt;实现一个简单的虚拟 DOM 渲染&lt;/h3&gt;&lt;figure clas
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="DOM" scheme="https://twentyshaw.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题4</title>
    <link href="https://twentyshaw.github.io/2019/11/17/JS%E4%BB%A3%E7%A0%81%E9%A2%984/"/>
    <id>https://twentyshaw.github.io/2019/11/17/JS代码题4/</id>
    <published>2019-11-17T09:30:36.000Z</published>
    <updated>2019-11-17T09:42:32.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现一个简单的模板引擎"><a href="#实现一个简单的模板引擎" class="headerlink" title="实现一个简单的模板引擎"></a>实现一个简单的模板引擎</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let template = &apos;&#123;&#123;name&#125;&#125;是&#123;&#123;color&#125;&#125;的&#123;&#123;stuff&#125;&#125;&apos;;</span><br><span class="line">let data = &#123;</span><br><span class="line">  name: &apos;香蕉&apos;,</span><br><span class="line">  color: &apos;黄色&apos;,</span><br><span class="line">  stuff: &apos;水果&apos;</span><br><span class="line">&#125;</span><br><span class="line">render(template, data); // 香蕉是黄色的水果</span><br></pre></td></tr></table></figure><p>实现render函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function render(template,data)&#123;</span><br><span class="line">var reg = /\&#123;\&#123;(\w+)\&#125;\&#125;/</span><br><span class="line">var item</span><br><span class="line">if (reg.test(template)) &#123;</span><br><span class="line">while(reg.exec(template) !== null)&#123;</span><br><span class="line">item = reg.exec(template)[1]</span><br><span class="line">template = template.replace(reg,data[item]) </span><br><span class="line">&#125;</span><br><span class="line">return template</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return &quot;没有可替换项目&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的主要考察正则的有关知识：</p><ul><li>圆括号</li><li>test()方法</li><li>exec()方法</li><li>replace()方法</li></ul><p>简单学习一下：</p><h4 id="1-正则表达式中的圆括号-→-（）"><a href="#1-正则表达式中的圆括号-→-（）" class="headerlink" title="1. 正则表达式中的圆括号 → （）"></a>1. 正则表达式中的圆括号 → （）</h4><p>看看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-capturing-parentheses" target="_blank" rel="noopener">MDN</a>的解释</p><blockquote><p>(x) : 它会匹配 ‘x’ 并且记住匹配项。其中括号被称为<strong>捕获括号</strong>。<br>模式 <code>/(foo) (bar) \1 \2/</code> 中的 ‘<code>(foo)</code>‘ 和 ‘<code>(bar)</code>‘ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 <code>\1</code> 和 <code>\2</code> 表示第一个和第二个被捕获括号匹配的子字符串，即 <code>foo</code> 和 <code>bar</code>，匹配了原字符串中的后两个单词。注意 <code>\1</code>、<code>\2</code>、…、<code>\n</code> 是用在正则表达式的匹配环节。而在正则表达式的替换环节，则要使用像 <code>$1</code>、<code>$2</code>、…、<code>$n</code> 这样的语法，例如，<code>&#39;bar foo&#39;.replace(/(...) (...)/, &#39;$2 $1&#39;)</code>。<code>$&amp;</code> 表示整个用于匹配的原字符串。</p></blockquote><ul><li>它会<strong>记住</strong>被匹配到的项目</li><li>可以在replace()方法中用<code>$n</code>调取第n个括号匹配到的内容</li></ul><h4 id="2-test-方法"><a href="#2-test-方法" class="headerlink" title="2. test()方法"></a>2. test()方法</h4><p>用法：<code>regexObj.test(str)</code>，返回一个true(存在匹配项目)或者false(不存在匹配项目)<br>如果正则表达式被设定为全局匹配，如：<code>/\{\{(\w+)\}\}/g</code>，那么它会查找整个表达式。虽然是否为全局匹配并不影响返回的结果，但是全局匹配的正则对象的test()方法每调用一次，它的lastIndex就会移动到被查找到的内容跟的最后一个字符的位置。<br>比如在本题中，如果在判断的时候调用了 <code>reg.test(template)</code>，那它后面的语句：<code>reg.exec(template)</code>的匹配的起始位置就不是从0位开始，而是从lastIndex=8的位置开始了。</p><h4 id="3-exec-方法"><a href="#3-exec-方法" class="headerlink" title="3. exec()方法"></a>3. exec()方法</h4><p>用法：<code>regexObj.exec(str)</code>，如果匹配失败会返回null。但如果匹配成功，会返回一个数组：</p><ul><li>数组第一项（arr[0]）：匹配到的内容</li><li>arr[1]~arr[n]：如果正则表达式中有圆括号的话，arr[n]为第n个圆括号中的内容。如果表达式中没有圆括号，那么这些项将不存在。</li><li>index属性：匹配到的字符位于原始字符串的基于0的索引值</li><li>input属性：原始字符串</li><li>等等</li></ul><p>如果正则表达式是全局匹配，那么和test()方法相同，每调用一次，正则对象的lastIndex都会改变，从而exec()会依次返回所有匹配的项目。但如果不是全局匹配，那无论调用几次exec()，都会返回第一次匹配到的内容。</p><h4 id="4-replace-方法"><a href="#4-replace-方法" class="headerlink" title="4. replace()方法"></a>4. replace()方法</h4><p>用法：<code>str.replace(regexp|substr, newSubStr|function)</code>，它会返回更新后的字符串</p><ul><li>regexp：正则对象/正则表达式。该正则所匹配的内容会被第二个参数的返回值替换掉。</li><li>substr：直接给出一个字符串来匹配</li><li>newSubStr：希望取代匹配到的内容的新的字符串</li><li>function：一个函数。该函数return的内容将取代匹配到的字符串。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实现一个简单的模板引擎&quot;&gt;&lt;a href=&quot;#实现一个简单的模板引擎&quot; class=&quot;headerlink&quot; title=&quot;实现一个简单的模板引擎&quot;&gt;&lt;/a&gt;实现一个简单的模板引擎&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="正则" scheme="https://twentyshaw.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议学习笔记（3）</title>
    <link href="https://twentyshaw.github.io/2019/11/17/HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    <id>https://twentyshaw.github.io/2019/11/17/HTTP协议学习笔记（3）/</id>
    <published>2019-11-17T02:07:04.000Z</published>
    <updated>2019-11-17T02:12:31.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><h4 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1. 三次握手"></a>1. 三次握手</h4><p>还是要祭出那张熟悉的图</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/5426662-d94f3226a689847c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自互联网"></p><ul><li><strong>第一次握手</strong>：首先由客户端主机主动发起建立连接的请求<br>该请求为一个TCP报文。该报文段首部中的SYN=1，ACK=0。由于SYN=1的报文段不能携带数据但会消耗一个序列号（由自身主机随机生成），所以假设它产生了一个值为x的序列号→seq=x。并且，ACK=0的报文段没有确认号（ack）。所以第一次握手的TCP报文首部为图示的：<br>SYN=1，seq=x</li><li><strong>第二次握手</strong>：服务端主机同意建立连接<br>服务端会响应一个TCP报文。该报文段首部SYN=1，ACK=1。<strong>发起连接和同意建立连接的SYN都为1。</strong>因为SYN=1，所以该报文段也会带上一个序列号，这个序列号也是由服务端自己随机生成的一个值。如图，假设它为y→seq=y。但是，由于本次报文中ACK=1，所以他有一个确认号ack，为服务端从对方主机（客户端）接收到的数据序列号（第一次握手发过来的seq=x）加上1，所以他的确认号为：<strong>ack=x+1</strong>。综上，第二次握手TCP报文首部为：<br>SYN=1，ACK=1，seq=y，ack=x+1</li><li><strong>第三次握手</strong>：客户端主机表示收到了服务端同意的消息<br>客户端收到服务端响应的消息后，它会再发一个TCP报文，来告诉服务端自己知道了。这个报文首部SYN=0，ACK=1。<strong>由于本次握手发送的报文SYN=0，所以报文段已经可以携带数据了</strong>。它的seq为自己在第一次握手随机创建的序列号（x）加1→seq=x+1。表示自己这次发送的TCP报文中的数据是接着上一次给对方发的数据包的（虽然上一次没有数据包）。然后，它的ack为服务端响应的seq的值加1→ack=y+1。表示你上次发的y我已经收到了，你可以给我发后面的数据（y+1）了。所以，本次握手的TCP报文为：<br>ACK=1，seq=x+1，ack=y+1</li></ul><p><strong>至此，完成了建立TCP连接的三次握手。从上面的过程中，我得出一个结论：序列号（seq）是用来标识自己本次发送的数据，确认号（ack）是用来提醒对方自己要接受的数据</strong></p><hr><h4 id="2-TCP连接的释放——四次挥手"><a href="#2-TCP连接的释放——四次挥手" class="headerlink" title="2. TCP连接的释放——四次挥手"></a>2. TCP连接的释放——四次挥手</h4><p>看看过程：<br><img src="https://upload-images.jianshu.io/upload_images/5426662-26b986db7a0be705.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自互联网"></p><p>数据传输结束后，通信双方可以关闭连接，并且停止发送数据。</p><ul><li><strong>第一次挥手</strong>：客户端主机主动请求关闭连接。<br>它会发送一个释放连接的报文段并且不携带任何数据。该报文段的FIN=1，seq为前面传输的数据序列号加1，假设他为u→seq=u。<strong>TCP规定，在FIN=1的报文段，即使没有携带数据也要消耗一个序列号。</strong>客户端发出这个报文以后，就进入终止等待1（FIN-WAIT-1）的阶段，等待服务端的响应。</li><li><strong>第二次挥手</strong>：服务端向客户端确认：我要开始释放连接了哦<br>服务端收到客户端传来的释放连接的报文段以后，会先返回一个确认的报文段。该报文段ACK=1，确认号为客户端传来的报文段的序列号加1→ack=u+1。他的序列号为自己前面发送的最后的数据的序列号加1 ，假设它为v→seq=v。<br>这时客户端收到这个确认报文以后会进入终止等待2（FIN-WAIT-2）的阶段，该阶段客户端已经不能再向服务端发送数据了，但是它还可以接收服务端发送过来的数据。</li><li><strong>第三次挥手</strong>：如果服务端已经没有要发给客户端的数据了，他会通知应用进程释放连接。<br>服务端发送一个报文段，FIN=1，ACK=1，确认号仍然是第二次挥手报文段中的确认号ack=u+1。序列号为第二次挥手时，最后传给客户端的数据的序列号加1，假设它为w→seq=w。</li><li><strong>第四次挥手</strong>：客户端收到服务端的确认报文以后，再次与服务端确认，告诉他自己会关闭连接。<br>客户端发送一个确认报文段，ACK=1，确认号为第三次握手中服务端传过来的序列号加1→ack=w+1。它的序列号为自己前一次（第一次握手时）发送的报文序列号加1→seq=u+1。<br>发出该报文后，客户端并不会马上关闭连接，它会进入TIME-WAIT状态。这是一个等待时间，可以自己设定。然而服务端收到报文以后会先马上进入CLOSED状态。客户端只有过了等待时间以后才进入CLOSED状态。二者都进入CLOSED状态后，连接就完全释放了</li></ul><p>至此，四次挥手完成，连接释放。<br>可以看到FIN=1这个字段，只会出现在客户端或服务端提醒对方要关闭连接的时候（第一次握手和第三次握手）。客户端或服务端在收到对方的关闭连接的报文后，都会与对方再次确认。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;三次握手与四次挥手&quot;&gt;&lt;a href=&quot;#三次握手与四次挥手&quot; class=&quot;headerlink&quot; title=&quot;三次握手与四次挥手&quot;&gt;&lt;/a&gt;三次握手与四次挥手&lt;/h3&gt;&lt;h4 id=&quot;1-三次握手&quot;&gt;&lt;a href=&quot;#1-三次握手&quot; class=&quot;headerlink&quot; title=&quot;1. 三次握手&quot;&gt;&lt;/a&gt;1. 三次握手&lt;/h4&gt;&lt;p&gt;还是要祭出那张熟悉的图&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="计算机基础" scheme="https://twentyshaw.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="HTTP" scheme="https://twentyshaw.github.io/tags/HTTP/"/>
    
      <category term="计算机基础" scheme="https://twentyshaw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议学习笔记（2）</title>
    <link href="https://twentyshaw.github.io/2019/11/14/HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <id>https://twentyshaw.github.io/2019/11/14/HTTP协议学习笔记（2）/</id>
    <published>2019-11-14T06:33:43.000Z</published>
    <updated>2019-11-14T06:34:58.940Z</updated>
    
    <content type="html"><![CDATA[<h3 id="客户端与服务端的通信与TCP连接"><a href="#客户端与服务端的通信与TCP连接" class="headerlink" title="客户端与服务端的通信与TCP连接"></a>客户端与服务端的通信与TCP连接</h3><h4 id="1-客户端与服务端的通信过程"><a href="#1-客户端与服务端的通信过程" class="headerlink" title="1. 客户端与服务端的通信过程"></a>1. 客户端与服务端的通信过程</h4><p>当客户端想要跟服务端进行信息交互时，过程如下：</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/5426662-30cb7d90d36b6a57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><h4 id="2-TCP连接"><a href="#2-TCP连接" class="headerlink" title="2. TCP连接"></a>2. TCP连接</h4><p>准备面试的时候背过好多次下面这个图，描述了TCP连接建立三次握手的过程：<br><img src="https://upload-images.jianshu.io/upload_images/5426662-d94f3226a689847c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自互联网"></p><p>当时只知道大致就是：</p><blockquote><p>客户端发送一个同步报文请求建立连接，服务端响应一个同步-应答报文表示可以建立连接，然后客户端再发送一个应答报文表示了解了。至此三次握手完成，TCP连接建立，客户端开始发送数据。</p></blockquote><p>上面的回答没有错，但感觉很粗略，现在通过分解知识点的方法来详细学习一下这个过程。</p><h5 id="2-1-首先来看一下TCP报文中包含哪些东西："><a href="#2-1-首先来看一下TCP报文中包含哪些东西：" class="headerlink" title="2.1 首先来看一下TCP报文中包含哪些东西："></a>2.1 首先来看一下TCP报文中包含哪些东西：</h5><p><img src="https://upload-images.jianshu.io/upload_images/5426662-7d857ea15f269183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自互联网"><br>结合三次握手那张图来看我认为自己目前需要了解的是：</p><ul><li><strong>序列号 **：就是握手过程中的那个</strong>seq**。<br>我们知到TCP之所以是可靠的因为他保证了传送数据包的顺序。这个顺序就是通过序列号来实现的。直接看一看定义：<blockquote><p>序列号占4个字节，序号的范围为[0,4284967296]。由于TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号。另外，序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了0。</p></blockquote></li></ul><p>看这段定义时我有点疑惑，他说<strong>“首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号”</strong>，但是在三次握手建立连接的过程中，TCP报文中应该没有带着数据的，那为什么还会有序列号呢？<br>学习的时候看到了一个解释：</p><blockquote><p>TCP规定，SYN=1的报文段不能携带数据（也就是说三次握手的前两次是不可以携带数据的），但要消耗掉一个序号。</p></blockquote><p>该序列号为<strong>初始序列号</strong>，由发起会话的主机随机产生，可能是0和4,294,967,295之间的任意值。<br>当服务端主机接收到请求时，会响应一个TCP报文，该报文中的序列号则是由服务端随机产生，不过该报文中会包含一个<strong>确认号（ack）</strong>，值为客户端的初始序列号+1。关于确认号在下面介绍。</p><hr><ul><li><strong>确认号：ack, 注意是小写啊</strong><blockquote><p>当ACK标志位为1时有效，表示期望收到的下一个报文段的第一个数据字节的序号。确认号为N，则表明到序列号N-1为止的所有数据字节都已经被正确地接收到了。</p></blockquote></li></ul><p>我自己的理解是，带有“ACK=1”字段的报文是主机表示了解，也就是跟对方确认自己收到了信息的意思。所以确认号就是用来表示：<br><strong>“你前一次传过来的数据（n）我都收到了，可以发后面的数据（n+1）了”</strong><br>所以用对方（前一次）的序列号＋1来表示我准备好接收后面的数据了。</p><hr><ul><li><strong>SYN：同步序号</strong><blockquote><p>用来发起一个连接。当SYN=1而ACK=0时，表明这是一个连接请求报文段，<strong>若对方同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。</strong></p></blockquote></li></ul><p>注意不管是发起连接会带有SYN字段，对请求的响应（同意建立连接）也会带上SYN<br>在带有SYN字段的TCP报文中，不能携带数据。</p><hr><ul><li><strong>ACK：确认序号</strong><blockquote><p>仅当ACK=1时确认号(ack)字段才有效，当ACK=0时，确认号无效。TCP规定，在连接建立后所有的传送报文段都必须把ACK置1。</p></blockquote></li></ul><p>就是表示好的，可以，我知道了。。。</p><hr><ul><li><strong>FIN：看字母也知道是finish的意思吧</strong><blockquote><p>用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放连接。</p></blockquote></li></ul><p>这个字段在解除连接（四次挥手）的时候会用到。</p><hr><p>今天就先学到这里，明天结合上面的知识点解释一下三次握手和四次挥手的过程~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;客户端与服务端的通信与TCP连接&quot;&gt;&lt;a href=&quot;#客户端与服务端的通信与TCP连接&quot; class=&quot;headerlink&quot; title=&quot;客户端与服务端的通信与TCP连接&quot;&gt;&lt;/a&gt;客户端与服务端的通信与TCP连接&lt;/h3&gt;&lt;h4 id=&quot;1-客户端与服务端的通信过程&quot;&gt;&lt;a href=&quot;#1-客户端与服务端的通信过程&quot; class=&quot;headerlink&quot; title=&quot;1. 客户端与服务端的通信过程&quot;&gt;&lt;/a&gt;1. 客户端与服务端的通信过程&lt;/h4&gt;&lt;p&gt;当客户端想要跟服务端进行信息交互时，过程如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="计算机基础" scheme="https://twentyshaw.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="HTTP" scheme="https://twentyshaw.github.io/tags/HTTP/"/>
    
      <category term="计算机基础" scheme="https://twentyshaw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>记录</title>
    <link href="https://twentyshaw.github.io/2019/11/14/%E8%AE%B0%E5%BD%95/"/>
    <id>https://twentyshaw.github.io/2019/11/14/记录/</id>
    <published>2019-11-14T03:43:18.000Z</published>
    <updated>2019-11-14T03:48:04.143Z</updated>
    
    <content type="html"><![CDATA[<h3 id="像是自虐一样，我已经打开cj那篇博客不下三次了。"><a href="#像是自虐一样，我已经打开cj那篇博客不下三次了。" class="headerlink" title="像是自虐一样，我已经打开cj那篇博客不下三次了。"></a>像是自虐一样，我已经打开cj那篇博客不下三次了。</h3><p>每当生活变得不如意的时候，当我的心情郁闷得不到疏解的时候，我总喜欢看看篇博客，让心情变得更糟糕一点。</p><a id="more"></a><p>那是关于他的，我的他。但是cj写这篇博客的时候他还不是我的。<br>那时还在大四，大学即将毕业，在准备来日本的材料。我觉得一切都还有希望。<br>cj把链接发给我让我看看，戏虐的问我看完什么感受。<br>难过吗？<br>我说，嗯，难过得想下去跑圈。<br>可是当时我并不怎么难过，至少不如现在难过。只是有点怅然若失，好像我奋力想抓住的东西，其实连它的影子都没有够到过。<br>当时我发了一条朋友圈：<br>「波罗叹了口气，他为自己不再年轻感到高兴」<br>我也是，为自己不再像十几岁那样固执感到高兴。</p><p>可是现在，在我真真切切的感受过他的一切，他手指的冰凉，怀抱的温暖，在经历过耳鬓厮磨过后，再来看那些句子，每个字都好像嘲笑。<br>我终究还是得到了他。<br>但他那些过往，他从六岁到二十岁喜欢念念不忘的姑娘，喝醉酒情绪崩溃时想的那个姑娘，是以一种怎样的形态存在在他的脑海里呢。<br>明明我也那些过去的时间里，但是为什么他总是说<br>是吗，记不清了欸</p><p>我太贪心了。<br>想占有他的全部这种想法太贪心了。吃到了糖连装糖的漂亮盒子也想收藏。</p><p>我觉得生活真的糟糕透了，<br>所以一次又一次打开那些文字，让自己被撕裂然后又自己愈合。<br>像是自虐一样。<br>连同其他伤口一起。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;像是自虐一样，我已经打开cj那篇博客不下三次了。&quot;&gt;&lt;a href=&quot;#像是自虐一样，我已经打开cj那篇博客不下三次了。&quot; class=&quot;headerlink&quot; title=&quot;像是自虐一样，我已经打开cj那篇博客不下三次了。&quot;&gt;&lt;/a&gt;像是自虐一样，我已经打开cj那篇博客不下三次了。&lt;/h3&gt;&lt;p&gt;每当生活变得不如意的时候，当我的心情郁闷得不到疏解的时候，我总喜欢看看篇博客，让心情变得更糟糕一点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常" scheme="https://twentyshaw.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="他" scheme="https://twentyshaw.github.io/tags/%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题3</title>
    <link href="https://twentyshaw.github.io/2019/11/12/JS%E4%BB%A3%E7%A0%81%E9%A2%983/"/>
    <id>https://twentyshaw.github.io/2019/11/12/JS代码题3/</id>
    <published>2019-11-12T13:00:33.000Z</published>
    <updated>2019-11-12T13:02:44.227Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最大差值"><a href="#最大差值" class="headerlink" title="最大差值"></a>最大差值</h3><p>给定一个未排序的数列，找到此数列在已排序状态下的两个相邻值的最大差值，少于两个值时返回0。例如：给定数列 [1,3,2,0,1,6,8] 则 最大差值为3。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function differ(arr)&#123;</span><br><span class="line">if (arr.length&lt;2) return 0</span><br><span class="line">arr.sort(function(a,b)&#123;</span><br><span class="line">return a-b</span><br><span class="line">&#125;)</span><br><span class="line">var maxDiffer = 0</span><br><span class="line">for (var i = 0; i &lt; arr.length-1; i++) &#123;</span><br><span class="line">if (arr[i+1] - arr[i] &gt; maxDiffer) &#123;</span><br><span class="line">maxDiffer = arr[i+1] - arr[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return maxDiffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到了数组方法sort()，复习一下：<br><code>arr.sort()</code></p><ul><li>该操作将arr排序后返回。原数组改变，返回的是排序后的数组。</li><li>可以接受一个函数作为参数，不传参的情况下将元素转换为字符串，然后比较它们的UTF-16代码单元值序列</li><li>传入一个函数的情况下：按照该函数指定的方法对arr进行排序。<br>  函数接受两个参数：a，b<br>  <strong>如果函数的返回值小于0，那么a排在b的前面，</strong><br>  <strong>如果函数的返回值等于0，那么a，b保持不动</strong><br>  <strong>如果函数的返回值大于0，那么a排在b的后面</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;最大差值&quot;&gt;&lt;a href=&quot;#最大差值&quot; class=&quot;headerlink&quot; title=&quot;最大差值&quot;&gt;&lt;/a&gt;最大差值&lt;/h3&gt;&lt;p&gt;给定一个未排序的数列，找到此数列在已排序状态下的两个相邻值的最大差值，少于两个值时返回0。例如：给定数列 [1,3,2,0,1,6,8] 则 最大差值为3。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="数组" scheme="https://twentyshaw.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议学习笔记(1)</title>
    <link href="https://twentyshaw.github.io/2019/11/11/HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://twentyshaw.github.io/2019/11/11/HTTP协议学习笔记-1/</id>
    <published>2019-11-11T05:48:25.000Z</published>
    <updated>2019-11-14T03:45:14.626Z</updated>
    
    <content type="html"><![CDATA[<p>先来看看MDN给出的定义：</p><blockquote><p>超文本传输​​协议（HTTP）是一个用于传输超媒体文档（例如 HTML）的应用层协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。<a id="more"></a>HTTP 遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP 是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 TCP/IP 层，但可以在任何可靠的传输层上使用；也就是说，不像 UDP，它是一个不会静默丢失消息的协议。</p></blockquote><p>其中涉及到的几个关键点：<br><strong>1. 超媒体文档</strong><br><strong>2. 应用层协议</strong><br><strong>3. 作用：客户端与服务端的通信</strong><br><strong>4. 无状态协议</strong><br><strong>5. TCP/IP 层</strong></p><h3 id="1-超媒体文档"><a href="#1-超媒体文档" class="headerlink" title="1. 超媒体文档"></a>1. 超媒体文档</h3><p>Web上的信息不同于我们平时看到的普通文本组成的线性信息，它是非线性的，<strong>超文本文件（hypertext）</strong>之间可以通过超链接来互相跳转。一个超文本文件就叫做一个网页。<br>Web上的信息不光只有超文本文件，还包括语音，图形，动画等。这些信息之间也可以由超链接互相连接，它们共同组成了<strong>超媒体文件（hypermedia）</strong>。</p><h3 id="2-应用层协议"><a href="#2-应用层协议" class="headerlink" title="2. 应用层协议"></a>2. 应用层协议</h3><p>互联网的实现，从上至下大致分为：<br><img src="https://upload-images.jianshu.io/upload_images/5426662-97d01324e4503360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>实体层靠近硬件，应用层靠近用户。<br>每一层为了完成自己特定的功能都要遵从一个规则，这个规则就称为协议。<br>应用层收到来自传输层的数据以后，要进行解读。由于传输层传过来的数据是各式各样的，比如有网页，文件，Email等。</p><blockquote><p><strong>“应用层”的作用，就是规定应用程序的数据格式。</strong></p></blockquote><p>想要合理的解读出这些数据，就需要根据不同的规则来解读。<br>HTTP就是其中一种规则，用来解读HTML这样的网络资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来看看MDN给出的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;超文本传输​​协议（HTTP）是一个用于传输超媒体文档（例如 HTML）的应用层协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="计算机基础" scheme="https://twentyshaw.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="HTTP" scheme="https://twentyshaw.github.io/tags/HTTP/"/>
    
      <category term="计算机基础" scheme="https://twentyshaw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题2</title>
    <link href="https://twentyshaw.github.io/2019/11/11/JS%E4%BB%A3%E7%A0%81%E9%A2%982/"/>
    <id>https://twentyshaw.github.io/2019/11/11/JS代码题2/</id>
    <published>2019-11-11T01:31:07.000Z</published>
    <updated>2019-11-11T01:32:56.054Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现千分位格式化"><a href="#实现千分位格式化" class="headerlink" title="实现千分位格式化"></a>实现千分位格式化</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function th(n)&#123;</span><br><span class="line">if (n&lt;1000) return</span><br><span class="line">var arr = n.toString().split(&apos;&apos;).reverse()</span><br><span class="line">var result = []</span><br><span class="line">var count = 0</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">result.unshift(arr[i])</span><br><span class="line">if (count&lt;arr.length-1 &amp;&amp; ++count % 3 === 0) &#123;</span><br><span class="line">result.unshift(&apos;,&apos;)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">return result.join(&apos;&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要注意判断count的时候限定count的大小</strong><br>如果不写<code>count&lt;arr.length-1</code>的话，当n为六位数时，会在第六位前面也加上一个“，”如：<br><img src="https://upload-images.jianshu.io/upload_images/5426662-b4e8bb82411c16d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实现千分位格式化&quot;&gt;&lt;a href=&quot;#实现千分位格式化&quot; class=&quot;headerlink&quot; title=&quot;实现千分位格式化&quot;&gt;&lt;/a&gt;实现千分位格式化&lt;/h3&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="数组" scheme="https://twentyshaw.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JS代码题1</title>
    <link href="https://twentyshaw.github.io/2019/11/10/JS%E4%BB%A3%E7%A0%81%E9%A2%981/"/>
    <id>https://twentyshaw.github.io/2019/11/10/JS代码题1/</id>
    <published>2019-11-10T05:22:28.000Z</published>
    <updated>2019-11-11T01:33:09.479Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）"><a href="#接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）" class="headerlink" title="接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）"></a>接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）</h3><a id="more"></a><h4 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1. 递归法"></a>1. 递归法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function output(m,n)&#123;</span><br><span class="line">let result = []</span><br><span class="line">if (m === 0) &#123;</span><br><span class="line">return result</span><br><span class="line">&#125;else&#123;</span><br><span class="line">result.unshift(n)</span><br><span class="line">return output(--m,n).concat(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用数组方法 <code>unshift()</code>来添加数组成员</li><li>使用数组方法 <code>concat()</code>来本轮结果与递归产生的数组</li></ul><h4 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2. Array.from()"></a>2. Array.from()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function output(m,n)&#123;</span><br><span class="line">return Array.from(&#123;length:m&#125;,v=&gt;n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6的Array.from()方法，它可将两类对象转化为数组：</p><ul><li>类似数组的对象：最本质的特征就是该对象要拥有<code>length</code>属性</li><li>可遍历的对象<br>Array.from()可以接受两个参数：</li><li>第一个参数是想要转成数组的对象</li><li>第二个参数是一个map方法。<br>与数组的map方法一致，第一个参数是数组成员→item，第二个参数（可省略）是数组的索引index，第三个参数（可省略）是数组本身</li></ul><p>基于第一个参数生成一个数组后，如果存在第二个参数，就对该数组进行map操作，并将map操作后的数组作为结果返回。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）&quot;&gt;&lt;a href=&quot;#接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）&quot; class=&quot;headerlink&quot; title=&quot;接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）&quot;&gt;&lt;/a&gt;接收两个参数m和n。返回一个数组，该数组长度为m，值为n。（不能使用循环）&lt;/h3&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://twentyshaw.github.io/categories/JavaScript/"/>
    
      <category term="刷题" scheme="https://twentyshaw.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://twentyshaw.github.io/tags/JS/"/>
    
      <category term="代码题" scheme="https://twentyshaw.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
      <category term="数组" scheme="https://twentyshaw.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
